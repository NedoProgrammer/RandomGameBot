const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const NAMESPACE = "RandomGameBot.Features.ObjectionLol.Characters";
const OUTPUT_DIRECTORY = "generated";
const SCREENSHOT_DIRECTORY = "generated_png";
const OBJECTION_FILE = "My Objection.objection";

(async () => {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    rl.question(`Do you already have backup.bak and ${OBJECTION_FILE}? (y/n)`, async (ans) => {
        ans === 'y' ? await CreateCode(): await CreateData();
        rl.close();
    });
})();

async function CreateCode()
{
    const characterInfo = JSON.parse(fs.readFileSync('backup.bak').toString());
    const charactersLength = characterInfo.length;
    const decoded = Buffer.from(fs.readFileSync(OBJECTION_FILE).toString(), 'base64').toString();
    const rendered = JSON.parse(decoded);
    console.log("---> Creating code");

    console.log(`[0/${charactersLength}] ---> ${OUTPUT_DIRECTORY}\\Character.cs`);
    fs.writeFileSync(path.join(__dirname, OUTPUT_DIRECTORY, "Character.cs"), `namespace {NAMESPACE};
/*
	Auto generated by my random js script.
	Additional Info:
		Total Character Count: ${charactersLength}
*/
public abstract class Character<T>
{
\tpublic T Emotion;
\tpublic string Username;
\tpublic string Text;
\tpublic Character(string username, T emotion, string text) 
\t{
\t\tUsername = username;
\t\tEmotion = emotion;
\t\tText = text;
\t}
}`.replaceAll("{NAMESPACE}", NAMESPACE))

    let count = 0;
    let ccount = 0;

    characterInfo.reverse();

    for (const character of characterInfo) {
        ccount++;
        console.log(`[${ccount}/${charactersLength}] ---> ${OUTPUT_DIRECTORY}\\${character.formattedName}.cs`);
        let emotionString = "";
        for (const emotion of character.emotions) {
            const frame = rendered.groups[0].frames[count];
            emotionString += `\t\t${emotion.formattedName} = ${frame.poseId},\n`;
            count++;
        }
        let name = path.join(__dirname, OUTPUT_DIRECTORY, character.formattedName + ".cs");
        fs.writeFileSync(name, `namespace {NAMESPACE};
/*
	Auto generated by my random js script.
	Additional Information:
		Raw Name: ${character.name}
		Formatted Name: ${character.formattedName}
		Emotion Count: ${character.emotions.length}
*/
public class {NAME} : Character<{NAME}.{NAME}Emotions>
{

\tpublic enum {NAME}Emotions
\t{
${emotionString}
\t}

\tpublic const string RawName = "${character.name}";

\tpublic {NAME}(string username, {NAME}.{NAME}Emotions emotion, string text) : base(username, emotion, text)
\t{
\t}
}`.replaceAll("{NAMESPACE}", NAMESPACE).replaceAll("{NAME}", character.formattedName));

    }
}

async function CreateData()
{
    console.log(`PLEASE CHECK THE FOLLOWING PROPERTIES BEFORE RUNNING THE SCRIPT!!\n\nNamespace: ${NAMESPACE}\nOutput directory: ${OUTPUT_DIRECTORY}\nScreenshot directory: ${SCREENSHOT_DIRECTORY}\nObject file: ${OBJECTION_FILE}\n\nIf they are not valid, immediately shutdown, edit, and rerun the script.\nProceeding in 10 seconds.`);
    await delay(10000);

    if (fs.existsSync(OUTPUT_DIRECTORY))
        fs.rmSync(OUTPUT_DIRECTORY, {recursive: true});
    if (fs.existsSync(SCREENSHOT_DIRECTORY))
        fs.rmSync(SCREENSHOT_DIRECTORY, {recursive: true});

    fs.mkdirSync(OUTPUT_DIRECTORY);
    fs.mkdirSync(SCREENSHOT_DIRECTORY);

    console.clear();
    console.log("Opening chromium");

    const browser = await puppeteer.launch({args: ['--start-maximized', '--disable-web-security'], headless: true});
    const page = await browser.newPage();

    console.log("Opening objection.lol");
    await page.goto('https://objection.lol/maker');
    await page.setViewport({
        width: 1920,
        height: 1080,
        deviceScaleFactor: 3
    });
    console.log("Injecting scripts");
    await page.addScriptTag({url: "https://code.jquery.com/jquery-3.6.0.min.js"});
    await page.addScriptTag({path: "functions.js"});
    console.log("Injected");

    console.log("---> Step 1: getting characters");
    const charactersLength = await page.evaluate(async () => {
        window.CharacterInfo = await window.GetCharacters();
        return window.CharacterInfo.length;
    });

    console.log(`Got ${charactersLength} characters\n---> Step 2: getting emotions`);
    await page.evaluate(() => window.OpenCharacterList());
    let totalFrameCount = 0;

    await page.evaluate(() => window.GetEmotion());
    for (let i = 0; i < charactersLength; i++) {
        console.log(`[${i + 1}/${charactersLength}]`)
        await page.evaluate(x => {
            window.CurrentIndex = x;
            window.OpenCharacterList();
        }, i);
        const selector = await page.evaluate(() => {
            return window.CharacterInfo[window.CurrentIndex].id;
        });
        try {
            await page.click("#" + selector);
        } catch (e) {
            console.log(`Failed to click element: ${e}`);
        }
        await delay(250);
        const obj = await page.$(".thumb-container.d-flex");
        await obj.screenshot({path: path.join(__dirname, SCREENSHOT_DIRECTORY, (i + 1).toString() + '.png'), });
        await page.evaluate(() => window.GetEmotion());
        totalFrameCount += await page.evaluate(() => window.CharacterInfo[CurrentIndex].emotions.length);
    }
    console.log("---> Step 3: creating frames");
    console.log("Getting characters");
    const characterInfo = JSON.parse(await page.evaluate(() => {
        return JSON.stringify(window.CharacterInfo.map(x => {
            return {
                name: x.name, id: x.id, emotions: x.emotions.map(y => {
                    return {name: y.name, id: y.id, formattedName: y.formattedName}}),
                formattedName: x.formattedName
            }
        }));
    }));
    console.log("Deleting first frame")
    await page.evaluate(() => {
        window.CloseCharacterMenu();
        window.DeleteFirstFrame();
    });

    console.log("THIS PROCESS MIGHT TAKE A WHOLE HOUR!");
    let frameCount = 0;
    for (const character of characterInfo) {
        const characterIndex = characterInfo.indexOf(character) + 1;
        for (const emotion of character.emotions) {
            const emotionIndex = character.emotions.indexOf(emotion) + 1;
            console.log(`Character ${characterIndex}/${characterInfo.length} | Emotion ${emotionIndex}/${character.emotions.length} | Total ${frameCount + 1}/${totalFrameCount}`);
            try {
                await page.evaluate(async () => {
                    window.CreateFrame();
                    await sleep(250);
                    window.OpenFirstFrame();
                    await sleep(250);
                    window.OpenCharacterList();
                    await sleep(250);
                });
                await page.click('#' + character.id);
                await delay(250);
                await page.evaluate(() => window.OpenEmotionList());
                await delay(250);
                await page.click('#' + emotion.id);
                await delay(250);
                await page.evaluate(() => window.CloseCharacterMenu());
                await delay(250);
                await page.type(".frameTextarea", `${character.formattedName} (${characterIndex}) | ${emotion.formattedName} (${emotionIndex})`);
                frameCount++;
            } catch (e) {
                console.error("something went really bad.. " + e);
                await page.evaluate(() => window.DeleteFirstFrame());
            }
        }
    }
    await delay(500);

    await page._client.send('Page.setDownloadBehavior', {
        behavior: 'allow',
        downloadPath: __dirname,
    });
    await page.evaluate(async () => await window.Save());

    await delay(5000);
    console.log("---> Step 4: processing JSON");
    console.log("Backing up..");
    fs.writeFileSync("backup.bak", JSON.stringify(characterInfo));
}

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));